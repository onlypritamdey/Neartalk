<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Neartalk â€“ Link Pairing (No Backend)</title>

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- LZ-String for compact URL hashes -->
  <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
</head>
<body class="bg-gray-900 text-white min-h-screen">
  <div class="max-w-2xl mx-auto p-4 space-y-4">
    <h1 class="text-3xl font-bold">Neartalk ğŸ”—</h1>

    <!-- Status Bar -->
    <div id="statusBar" class="px-4 py-3 rounded bg-gray-800 text-yellow-300">
      Status: Idle
    </div>

    <!-- Actions -->
    <div class="grid md:grid-cols-2 gap-4">
      <!-- Host -->
      <div class="p-4 rounded bg-gray-800">
        <h2 class="text-xl font-semibold mb-2">Start a session (Host)</h2>
        <button id="startBtn" class="w-full py-2 rounded bg-blue-600 hover:bg-blue-700">Start session â†’ create offer link</button>
        <div class="mt-3 space-y-2">
          <textarea id="offerLink" class="w-full h-28 p-2 rounded text-black" placeholder="Offer link will appear hereâ€¦" readonly></textarea>
          <div class="flex gap-2">
            <button id="copyOffer" class="flex-1 py-2 rounded bg-blue-500 hover:bg-blue-600">Copy Offer Link</button>
            <button id="resetBtn" class="px-3 py-2 rounded bg-gray-700 hover:bg-gray-600">Reset</button>
          </div>
        </div>
        <p class="text-sm text-gray-300 mt-2">Send the Offer Link to your peer. When they reply with an Answer Link, paste/open it below.</p>
        <div class="mt-3 space-y-2">
          <input id="answerLinkInput" class="w-full p-2 rounded text-black" placeholder="Paste the Answer Link here and press Apply" />
          <button id="applyAnswer" class="w-full py-2 rounded bg-yellow-600 hover:bg-yellow-700">Apply Answer Link</button>
        </div>
      </div>

      <!-- Joiner -->
      <div class="p-4 rounded bg-gray-800">
        <h2 class="text-xl font-semibold mb-2">Join a session (Peer)</h2>
        <p class="text-sm text-gray-300 mb-2">Open the Offer Link you received. If it didnâ€™t auto-load, paste it below and press â€œLoad Offerâ€.</p>
        <input id="offerLinkInput" class="w-full p-2 rounded text-black" placeholder="Paste Offer Link hereâ€¦" />
        <div class="mt-2 flex gap-2">
          <button id="loadOffer" class="flex-1 py-2 rounded bg-green-600 hover:bg-green-700">Load Offer</button>
          <button id="generateAnswer" class="flex-1 py-2 rounded bg-purple-600 hover:bg-purple-700" disabled>Generate Answer Link</button>
        </div>
        <textarea id="answerLinkOut" class="w-full h-28 p-2 rounded text-black mt-3" placeholder="Answer link will appear hereâ€¦" readonly></textarea>
        <button id="copyAnswer" class="w-full mt-2 py-2 rounded bg-purple-500 hover:bg-purple-600" disabled>Copy Answer Link</button>
      </div>
    </div>

    <!-- Chat -->
    <div id="chatWrap" class="p-4 rounded bg-gray-800 hidden">
      <h2 class="text-xl font-semibold mb-2">Chat</h2>
      <div id="messages" class="h-64 overflow-y-auto rounded border border-gray-700 p-2"></div>
      <div class="mt-2 flex gap-2">
        <input id="msgInput" class="flex-1 p-2 rounded text-black" placeholder="Type a messageâ€¦" />
        <button id="sendBtn" class="px-4 py-2 rounded bg-indigo-600 hover:bg-indigo-700">Send</button>
      </div>
    </div>

    <p class="text-xs text-gray-400">
      Tip: Links use the URL hash (after <code>#</code>) and LZ compression. They can still be long; prefer sharing via
      a messenger or AirDrop. No data ever leaves the two browsersâ€”no backend is used.
    </p>
  </div>

<script>
  // ---------- UI helpers ----------
  const $ = s => document.querySelector(s);
  const statusBar = $('#statusBar');
  const setStatus = (t, color='text-yellow-300') => {
    statusBar.textContent = 'Status: ' + t;
    statusBar.className = 'px-4 py-3 rounded bg-gray-800 ' + color;
  };
  const copyText = async el => {
    try { await navigator.clipboard.writeText(el.value || el.textContent); } catch {}
  };

  // ---------- WebRTC state ----------
  let pc, dc;
  let localCandidates = [];
  let role = null; // 'host' or 'peer'

  const rtcConfig = {
    iceServers: [
      { urls: ['stun:stun.l.google.com:19302','stun:global.stun.twilio.com:3478'] }
    ]
  };

  function newPC() {
    pc = new RTCPeerConnection(rtcConfig);

    pc.onicecandidate = (e) => {
      if (e.candidate) localCandidates.push(e.candidate);
    };

    pc.onconnectionstatechange = () => {
      if (pc.connectionState === 'connected') {
        setStatus('Connected âœ…', 'text-green-400');
        $('#chatWrap').classList.remove('hidden');
      } else if (pc.connectionState === 'failed') {
        setStatus('Connection failed. Try again.', 'text-red-400');
      }
    };

    pc.ondatachannel = (e) => {
      dc = e.channel;
      wireDC();
    };
  }

  function wireDC() {
    if (!dc) return;
    dc.onopen = () => setStatus('Connected âœ… Data channel open', 'text-green-400');
    dc.onclose = () => setStatus('Data channel closed', 'text-orange-300');
    dc.onmessage = (ev) => addMsg('Peer', ev.data);
  }

  function addMsg(sender, text) {
    const box = $('#messages');
    const line = document.createElement('div');
    line.className = 'py-1';
    line.textContent = sender + ': ' + text;
    box.appendChild(line);
    box.scrollTop = box.scrollHeight;
  }

  // Wait until ICE gathering is complete (so candidates are baked into SDP)
  function waitIceComplete() {
    return new Promise(resolve => {
      if (!pc) return resolve();
      if (pc.iceGatheringState === 'complete') return resolve();
      const check = () => {
        if (pc.iceGatheringState === 'complete') {
          pc.removeEventListener('icegatheringstatechange', check);
          resolve();
        }
      };
      pc.addEventListener('icegatheringstatechange', check);
      // safety timeout in case some browsers linger
      setTimeout(resolve, 2500);
    });
  }

  // Pack/unpack payload into URL hash
  function encodePayload(obj) {
    try {
      const raw = JSON.stringify(obj);
      return LZString.compressToEncodedURIComponent(raw);
    } catch { return ''; }
  }
  function decodePayload(s) {
    try {
      const raw = LZString.decompressFromEncodedURIComponent(s);
      return JSON.parse(raw);
    } catch { return null; }
  }

  function makeLink(kind, payload) {
    const encoded = encodePayload(payload);
    return `${location.origin}${location.pathname}#${kind}=${encoded}`;
  }

  // ---------- Host flow ----------
  async function startHost() {
    role = 'host';
    setStatus('Creating offerâ€¦');
    localCandidates = [];
    newPC();

    // Create data channel from host side
    dc = pc.createDataChannel('chat');
    wireDC();

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    await waitIceComplete();

    // Include SDP and any separately captured candidates (belt & suspenders)
    const payload = { sdp: pc.localDescription, candidates: localCandidates };
    const link = makeLink('offer', payload);
    $('#offerLink').value = link;
    setStatus('Offer ready. Send link to your peer.', 'text-blue-300');
  }

  async function applyAnswerFromLink(linkStr) {
    try {
      const hash = (linkStr || '').split('#')[1] || '';
      const [tag, data] = hash.split('=');
      if (tag !== 'answer' || !data) throw new Error('Invalid answer link');

      const payload = decodePayload(data);
      if (!payload?.sdp) throw new Error('Malformed answer payload');

      await pc.setRemoteDescription(payload.sdp);
      // If separate candidates provided, add them (often already in SDP)
      if (Array.isArray(payload.candidates)) {
        for (const c of payload.candidates) {
          try { await pc.addIceCandidate(c); } catch {}
        }
      }
      setStatus('Applied answer. Waiting for connectionâ€¦', 'text-purple-300');
    } catch (e) {
      setStatus('Failed to apply answer link.', 'text-red-400');
      console.error(e);
    }
  }

  // ---------- Peer flow ----------
  let loadedOfferPayload = null;

  function tryAutoloadFromHash() {
    const h = location.hash.slice(1);
    if (!h) return;
    const [tag, data] = h.split('=');
    if (tag === 'offer' && data) {
      const payload = decodePayload(data);
      if (payload?.sdp) {
        $('#offerLinkInput').value = location.href;
        loadedOfferPayload = payload;
        $('#generateAnswer').disabled = false;
        setStatus('Offer detected from link. Ready to generate answer.', 'text-green-300');
      }
    } else if (tag === 'answer' && data) {
      // If host opens the answer link directly
      applyAnswerFromLink(location.href);
    }
  }

  async function loadOfferFromInput() {
    try {
      const linkStr = $('#offerLinkInput').value.trim();
      const hash = linkStr.split('#')[1] || '';
      const [tag, data] = hash.split('=');
      if (tag !== 'offer' || !data) throw new Error('Invalid offer link');

      const payload = decodePayload(data);
      if (!payload?.sdp) throw new Error('Malformed offer payload');
      loadedOfferPayload = payload;
      $('#generateAnswer').disabled = false;
      setStatus('Offer loaded. You can generate the answer now.', 'text-green-300');
    } catch (e) {
      setStatus('Failed to load offer link.', 'text-red-400');
      console.error(e);
    }
  }

  async function generateAnswer() {
    if (!loadedOfferPayload) return;
    role = 'peer';
    setStatus('Applying offerâ€¦');
    localCandidates = [];
    newPC();

    await pc.setRemoteDescription(loadedOfferPayload.sdp);
    if (Array.isArray(loadedOfferPayload.candidates)) {
      for (const c of loadedOfferPayload.candidates) {
        try { await pc.addIceCandidate(c); } catch {}
      }
    }

    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    await waitIceComplete();

    const payload = { sdp: pc.localDescription, candidates: localCandidates };
    const link = makeLink('answer', payload);
    $('#answerLinkOut').value = link;
    $('#copyAnswer').disabled = false;
    setStatus('Answer ready. Send this link back to the host.', 'text-purple-300');
  }

  // ---------- Chat ----------
  $('#sendBtn').addEventListener('click', () => {
    const t = $('#msgInput').value.trim();
    if (!t || !dc || dc.readyState !== 'open') return;
    dc.send(t);
    addMsg('You', t);
    $('#msgInput').value = '';
  });

  // ---------- Wire up UI ----------
  $('#startBtn').addEventListener('click', startHost);
  $('#copyOffer').addEventListener('click', () => copyText($('#offerLink')));
  $('#resetBtn').addEventListener('click', () => {
    location.hash = '';
    location.reload();
  });

  $('#applyAnswer').addEventListener('click', () => {
    const s = $('#answerLinkInput').value.trim();
    applyAnswerFromLink(s);
  });

  $('#loadOffer').addEventListener('click', loadOfferFromInput);
  $('#generateAnswer').addEventListener('click', generateAnswer);
  $('#copyAnswer').addEventListener('click', () => copyText($('#answerLinkOut')));

  // Try to auto-handle links opened directly
  tryAutoloadFromHash();
</script>
</body>
</html>
