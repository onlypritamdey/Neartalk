<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>NearTalk ‚Äî QR P2P (TURN-enabled)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { --pad: 14px; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:0; padding:var(--pad); }
  h1 { font-size: 20px; margin: 0 0 10px; }
  .row { display:flex; gap:8px; flex-wrap: wrap; align-items:center; }
  button { padding:10px 14px; border:1px solid #ccc; border-radius:8px; background:#fff; }
  #qrCanvas { margin:16px auto; display:flex; justify-content:center; }
  #reader { width: min(360px, 92vw); margin:0 auto; }
  .panel { border:1px solid #e5e5e5; border-radius:10px; padding:var(--pad); margin-top:12px; }
  pre { margin:0; white-space:pre-wrap; word-wrap:break-word; background:#f6f6f6; padding:10px; border-radius:6px; max-height:240px; overflow:auto; }
  textarea { width:100%; min-height:100px; padding:10px; border:1px solid #ddd; border-radius:6px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .tabs { display:flex; gap:8px; margin-top:8px; }
  .tab-btn { padding:8px 10px; border:1px solid #ddd; background:#fafafa; border-radius:6px; }
  .tab-btn.active { background:#fff; border-color:#bbb; font-weight:600; }
  .hidden { display:none; }
  small { color:#666; }
</style>
</head>
<body>
  <h1>NearTalk ‚Äî QR P2P (TURN-enabled)</h1>
  <div class="row">
    <button id="createBtn">Create (Offer)</button>
    <button id="joinBtn">Join (Answer)</button>
    <button id="scanBtn" class="hidden">Scan Now</button>
  </div>

  <div class="panel">
    <div class="tabs">
      <button class="tab-btn active" data-tab="qr">QR</button>
      <button class="tab-btn" data-tab="manual">Manual</button>
    </div>

    <div id="tab-qr">
      <div id="qrCanvas"></div>
      <div id="reader"></div>
      <small>Tip: hold the other device steady ~20‚Äì30 cm away. Back camera is preferred.</small>
    </div>

    <div id="tab-manual" class="hidden">
      <p><b>Manual fallback (copy/paste)</b></p>
      <p><i>Step A:</i> On the device that clicked <b>Create</b> or <b>Join</b>, copy the text below and send it to the other device.</p>
      <textarea id="signalOut" readonly></textarea>
      <div class="row">
        <button id="copyOutBtn">Copy Out</button>
      </div>
      <p style="margin-top:10px;"><i>Step B:</i> Paste the text you got from the other device here, then click <b>Apply Incoming</b>.</p>
      <textarea id="signalIn" placeholder="Paste incoming offer/answer here"></textarea>
      <div class="row">
        <button id="applyInBtn">Apply Incoming</button>
      </div>
    </div>
  </div>

  <div class="panel">
    <b>Debug Log</b>
    <pre id="log"></pre>
  </div>

  <!-- Libraries (served over HTTPS/CDN; fine for Vercel/GitHub Pages) -->
  <script src="https://cdn.jsdelivr.net/npm/simple-peer@9.11.1/simplepeer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>

<script>
(() => {
  let peer = null;
  let html5QrCode = null;
  let role = null; // 'offer' or 'answer'
  const logBox = document.getElementById('log');
  const scanBtn = document.getElementById('scanBtn');
  const signalOut = document.getElementById('signalOut');
  const signalIn = document.getElementById('signalIn');

  // --- UI helpers ---
  function log(msg) {
    const time = new Date().toLocaleTimeString();
    const line = `[${time}] ${msg}`;
    console.log(line);
    logBox.textContent += (logBox.textContent ? "\n" : "") + line;
    logBox.scrollTop = logBox.scrollHeight;
  }

  function showQR(text) {
    const qrDiv = document.getElementById('qrCanvas');
    qrDiv.innerHTML = '';
    // Slightly bigger QR for long SDPs
    QRCode.toCanvas(text, { width: 300 }, (err, canvas) => {
      if (err) { log("‚ùå QR generation error: " + err); return; }
      qrDiv.appendChild(canvas);
      log("‚úÖ QR generated (" + text.length + " chars)");
    });
  }

  // --- Tabs (QR / Manual) ---
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      const target = btn.dataset.tab;
      document.getElementById('tab-qr').classList.toggle('hidden', target !== 'qr');
      document.getElementById('tab-manual').classList.toggle('hidden', target !== 'manual');
    });
  });

  // --- Camera / QR scan ---
  function startScanner() {
    log("Starting QR scanner‚Ä¶");
    if (html5QrCode) {
      // cleanup previous
      try { html5QrCode.stop(); } catch(e) {}
      html5QrCode = null;
    }
    html5QrCode = new Html5Qrcode("reader");

    Html5Qrcode.getCameras().then(devices => {
      if (!devices || !devices.length) { log("‚ùå No camera found"); return; }
      // Prefer back camera
      let cam = devices.find(d => /back|rear|environment/i.test(d.label)) || devices[0];
      log("üì∑ Using camera: " + (cam.label || "(no label)"));

      html5QrCode.start(
        cam.id,
        { fps: 10, qrbox: 260 },
        decodedText => {
          log("üì• QR scanned (" + decodedText.length + " chars)");
          try {
            const signal = JSON.parse(decodedText);
            log("Signal parsed, type=" + signal.type);
            peer.signal(signal);
            stopScanner();
          } catch (e) {
            log("‚ùå Could not parse QR JSON: " + e);
          }
        }
      ).catch(err => log("‚ùå QR scanner start error: " + err));
    }).catch(err => log("‚ùå Camera access error: " + err));
  }

  function stopScanner() {
    if (html5QrCode) {
      html5QrCode.stop()
        .then(() => { log("Scanner stopped"); document.getElementById('reader').innerHTML = ''; })
        .catch(e => log("Scanner stop error: " + e));
    }
    scanBtn.classList.add('hidden');
  }

  scanBtn.addEventListener('click', startScanner);

  // --- TURN/STUN config (public relay; fine for testing) ---
  const rtcConfig = {
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:global.stun.twilio.com:3478?transport=udp' },
      {
        urls: [
          'turn:openrelay.metered.ca:80',
          'turn:openrelay.metered.ca:443',
          'turns:openrelay.metered.ca:443'
        ],
        username: 'openrelayproject',
        credential: 'openrelayproject'
      }
    ]
  };

  function attachDeepRtcLogging(p) {
    // These use the underlying RTCPeerConnection for richer logs.
    try {
      const pc = p._pc || p._channel && p._channel.peerConnection;
      if (!pc) return;

      pc.addEventListener('icegatheringstatechange', () =>
        log("iceGatheringState: " + pc.iceGatheringState));
      pc.addEventListener('iceconnectionstatechange', () =>
        log("iceConnectionState: " + pc.iceConnectionState));
      pc.addEventListener('connectionstatechange', () =>
        log("peerConnectionState: " + pc.connectionState));
      pc.addEventListener('signalingstatechange', () =>
        log("signalingState: " + pc.signalingState));
    } catch (e) {
      log("RTC logging hook error: " + e);
    }
  }

  // --- Create / Join flows ---
  function createPeer(initiator) {
    if (peer) {
      try { peer.destroy(); } catch (e) {}
      peer = null;
    }

    log("Creating peer (initiator=" + initiator + ")‚Ä¶");
    peer = new SimplePeer({
      initiator,
      trickle: false, // single big offer/answer (easier for QR/manual)
      config: rtcConfig
    });

    attachDeepRtcLogging(peer);

    peer.on('signal', data => {
      const payload = JSON.stringify(data);
      // Update both QR & Manual
      showQR(payload);
      signalOut.value = payload;
      log((initiator ? "Offer" : "Answer") + " signal ready (" + payload.length + " chars)");
      // Show Scan button for the response
      scanBtn.classList.remove('hidden');
    });

    peer.on('connect', () => {
      log("‚úÖ Data channel connected!");
      // quick sanity ping
      try { peer.send("hello from " + (initiator ? "offer" : "answer")); } catch(e) {}
    });

    peer.on('data', d => log("üì® Data received: " + new TextDecoder().decode(d)));

    peer.on('error', err => log("‚ùå Peer error: " + err));
    peer.on('close', () => log("üîå Peer closed"));

    // For some browsers, creating a datachannel early helps:
    try { if (initiator) peer.send("priming‚Ä¶"); } catch(e) {}
  }

  document.getElementById('createBtn').addEventListener('click', () => {
    role = 'offer';
    createPeer(true);
  });

  document.getElementById('joinBtn').addEventListener('click', () => {
    role = 'answer';
    createPeer(false);
  });

  // --- Manual fallback controls ---
  document.getElementById('copyOutBtn').addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(signalOut.value);
      log("üìã Copied Out to clipboard");
    } catch (e) {
      log("Clipboard copy failed: " + e);
    }
  });

  document.getElementById('applyInBtn').addEventListener('click', () => {
    const text = signalIn.value.trim();
    if (!text) { log("No incoming signal text to apply"); return; }
    try {
      const obj = JSON.parse(text);
      log("Applying incoming " + (obj.type || "signal") + "‚Ä¶");
      peer.signal(obj);
    } catch (e) {
      log("‚ùå Incoming signal JSON parse error: " + e);
    }
  });

  // --- Helpful runtime checks ---
  window.addEventListener('load', () => {
    const isHttps = location.protocol === 'https:';
    if (!isHttps && location.hostname !== 'localhost') {
      log("‚ö†Ô∏è Not HTTPS. Camera/WebRTC may fail. Deploy on Vercel/GitHub Pages for HTTPS.");
    } else {
      log("üîê Secure context OK (" + location.protocol + ")");
    }
    log("Ready. Tap Create on one phone and Join on another.");
  });
})();
</script>
</body>
</html>
